/// This module provides syntax for generating HTML and XML documents from inside of D,
/// including control flow.
module elemi.generator;

/// Elements are created using a tilde, followed by curly braces. This syntax is called an
/// **element block**.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.div ~ {
            html.span ~ { };
        };
    };
    assert(output == "<div><span></span></div>");
}

/// Instead of a block, you can follow an element with a string to specify text content.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.p ~ "Hello, World!";
    };
    assert(output == "<p>Hello, World!</p>");
}

/// You can add attributes to an element using the [Tag.attr] method.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.a.attr("href", "https://example.com") ~ "Visit my website!";
    };
    assert(output == `<a href="https://example.com">Visit my website!</a>`);
}

/// Common HTML attributes are available through methods.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.div.id("my-div") ~ { };
        html.div.classes("one", "two", "three") ~ { };
        html.a.href("https://example.com") ~ { };
    };
    assert(output == `<div id="my-div"></div>`
        ~ `<div class="one two three"></div>`
        ~ `<a href="https://example.com"></a>`);
}

/// Generate HTML tags with code.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.ul ~ {
            foreach (item; ["1", "2", "3"]) {
                html.li ~ item;
            }
        };
    };
    assert(output == `<ul><li>1</li><li>2</li><li>3</li></ul>`);
}

/// Omit the tag name to append text.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ "Hello, ";
        html.strong ~ "World!";
    };
    assert(output == "Hello, <strong>World!</strong>");
}

/// All HTML content is automatically escaped.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ "<script>alert('fool!')</script>";
        html.input.attr("value", "\" can't quit me") ~ { };
        html.div.classes("classes are <no exception>") ~ { };
    };

    assert(output == `&lt;script&gt;alert(&#39;fool!&#39;)&lt;/script&gt;`
        ~ `<input value="&quot; can&#39;t quit me"/>`
        ~ `<div class="classes are &lt;no exception&gt;"></div>`);
}

static if (withInterpolation) {
    /// Interpolated expression strings, aka istrings, are supported.
    unittest {
        string output = buildHTML() ~ (html) {
            const user = "<user>";
            html ~ i"Hello $(user)";
            html.div ~ i"Hello $(user)";
            html.div.attr("name", i"$(user)") ~ { };
            html.a.href(i"https://example.com/$(user)") ~ { };
            html.a
                .classes("button", "special")
                .href("https://example.com/") ~ { };
        };
        assert(output == `Hello &lt;user&gt;`
            ~ `<div>Hello &lt;user&gt;</div>`
            ~ `<div name="&lt;user&gt;"></div>`
            ~ `<a href="https://example.com/&lt;user&gt;"></a>`
            ~ `<a class="button special" href="https://example.com/"></a>`);
    }
}

static if (withInterpolation) {

    /// This syntax can be mixed with elements generated by the old syntax.
    @safe unittest {
        string output = buildHTML() ~ (html) {
            html ~ elem!"span"();
            html.div ~ elem!"span"();
            html ~ i"$(elem!"span"())";
        };
        assert(output == `<span></span>`
            ~ `<div><span></span></div>`
            ~ `<span></span>`);
    }

}

/// Elemi works at compile time!
@safe unittest {
    enum output = buildHTML ~ (html) {
        html.div ~ {
            html.p ~ "Hello, World!";
        };
    };
    assert(output == "<div><p>Hello, World!</p></div>");
}

@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ elem!"p"("Hello, World!");
    };

    assert(output == "<p>Hello, World!</p>");
}

@safe unittest {
    // const(edgecase)
    const element = elem!"p"("Hello, World!");
    string output = buildHTML() ~ (html) {
        html ~ element;
        html ~ i" with $(element)";
    };

    assert(output == "<p>Hello, World!</p> with <p>Hello, World!</p>");
}

import std.meta;
import std.range;
import std.string;
import std.functional;

import elemi.html;
import elemi.element;
import elemi.internal;
import elemi.attribute;

static if (__traits(compiles, { import core.attribute : mustuse; })) {
    import core.attribute : mustuse;
}
else {
    alias mustuse = AliasSeq!();
}

@safe:

/// This special struct writes XML or HTML elements through a predicate function. It accepts an
/// element block `~ { }` as input.
///
/// The predicate can be used with `std.range.input` to write content to an input range.
@mustuse
struct DocumentBuilder {

    void delegate(string fragment) @safe sink;

    void opBinary(string op : "~")(void delegate() @safe build) @safe {
        elementOutput = (string fragment) => unaryFun!fun(fragment);
        scope (exit) elementOutput = null;
        build();
    }

    void opBinary(string op : "~")(void delegate() @system build) @system {
        elementOutput = (string fragment) => unaryFun!fun(fragment);
        scope (exit) elementOutput = null;
        build();
    }

}

/// This special struct writes XML or HTML elements to a string.
///
/// The resulting string is wrapped in an [Element] so it is recognized as a valid element
/// by other parts of the Elemi API.
@mustuse
struct TextDocumentBuilder {

    Element opBinary(string op : "~")(void delegate() @safe build) @safe {
        Appender!string output;
        elementOutput = (string fragment) => output ~= fragment;
        scope (exit) elementOutput = null;
        build();
        return elemTrusted(output[]);
    }

    Element opBinary(string op : "~")(void delegate() @system build) @system {
        Appender!string output;
        elementOutput = (string fragment) => output ~= fragment;
        scope (exit) elementOutput = null;
        build();
        return elemTrusted(output[]);
    }

}

/// Generic XML tag.
@mustuse
struct Tag {

    /// Output target for this tag; HTML code will be written to this destination.
    DocumentOutput output;

    /// Name of this HTML tag.
    string tagName;

    /// If true, this is a "self-closing" tag. No child nodes or text can be added.
    bool isSelfClosing;

    alias output this;

    /// The tag can be marked as self-closing so it does not generate content nor an end tag.
    unittest {
        auto normal = buildHTML() ~ (html) {
            Tag(html, "a") ~ { };
        };
        auto selfClosing = buildHTML() ~ (html) {
            Tag(html, "a").makeSelfClosing() ~ { };
        };

        assert(normal == "<a></a>");
        assert(selfClosing == "<a/>");
    }

    unittest {
        auto normal = buildHTML() ~ (html) {
            Tag(html, "a").attr("k", "k") ~ { };
        };
        auto selfClosing = buildHTML() ~ (html) {
            Tag(html, "a").attr("k", "k").makeSelfClosing() ~ { };
        };

        assert(normal == `<a k="k"></a>`);
        assert(selfClosing == `<a k="k"/>`);
    }

    /// True if an attribute has been added to this tag.
    ///
    /// This changes whether the whole opening tag will be added when content starts (no
    /// attributes), or just the right bracket (with attributes).
    bool withAttributes;

    /// Returns:
    ///     The same tag, but marked using [withAttributes]. This should be used to return from
    ///     attribute-adding methods.
    Tag attributed() const @safe {
        return Tag(output, tagName, isSelfClosing, true);
    }

    /// Returns:
    ///     This tag, but edited to be self-closing.
    Tag makeSelfClosing() const @safe {
        return Tag(output, tagName, true, withAttributes);
    }

    void opBinary(string op : "~")(typeof(null)) @safe {
        begin();
        end();
    }

    void opBinary(string op : "~", T)(T content) @safe {
        begin();
        if (!isSelfClosing) {
            static if (is(T : const Element)) {
                pushElementMarkup(content);
            }
            else {
                pushElementText(content);
            }
            end();
        }
    }

    static if (withInterpolation)
    void opBinary(string op : "~", Ts...)(InterpolationHeader, Ts text) {
        begin();
        if (!isSelfClosing) {
            pushElementText(text);
            end();
        }
    }

    void opBinary(string op : "~")(void delegate() @safe builder) @safe {
        begin();
        if (!isSelfClosing) {
            builder();
            end();
        }
    }

    void opBinary(string op : "~")(void delegate() @system builder) @system {
        begin();
        if (!isSelfClosing) {
            builder();
            end();
        }
    }

    /// Add an attribute to the element.
    /// Params:
    ///     name  = Name of the attribute.
    ///     value = Value for the attribute. Supports istrings.
    /// Returns:
    ///     Tag builder.
    Tag attr(string name, string value) @safe {
        return attr(Attribute(name, value));
    }

    /// ditto
    static if (withInterpolation) {
        Tag attr(Ts...)(string name, InterpolationHeader, Ts value) @safe {
            beginAttributes();
            pushElementMarkup(" ");
            pushElementMarkup(name);
            pushElementMarkup(`="`);
            pushElementText(value);
            pushElementMarkup(`"`);
            return attributed;
        }
    }

    /// Add a prepared set of attributes to the element.
    /// Params:
    ///     attributes = Attributes to add to the element.
    /// Returns:
    ///     Tag builder.
    Tag attr(Attribute[] attributes...) @safe {
        beginAttributes();
        foreach (attribute; attributes) {
            pushElementMarkup(" ");
            pushElementMarkup(attribute.name);
            pushElementMarkup(`="`);
            pushElementText(attribute.value);
            pushElementMarkup(`"`);
        }
        return attributed;
    }

    void begin() @safe {
        if (tagName is null) return;
        if (!withAttributes) {
            pushElementMarkup("<");
            pushElementMarkup(tagName);
        }
        if (isSelfClosing) {
            pushElementMarkup("/>");
        }
        else {
            pushElementMarkup(">");
        }
    }

    void beginAttributes() @safe {
        if (tagName is null) return;
        if (!withAttributes) {
            pushElementMarkup("<");
            pushElementMarkup(tagName);
        }
    }

    void end() @safe {
        if (tagName is null) return;
        if (!isSelfClosing) {
            pushElementMarkup("</");
            pushElementMarkup(tagName);
            pushElementMarkup(">");
        }
    }

}

struct DocumentOutput {

    void delegate(string fragment) @safe elementOutput;

    void opBinary(string op : "~", T : string)(T rhs) @safe {
        static if (is(T : const Element)) {
            pushElementMarkup(rhs);
        }
        else {
            pushElementText(rhs);
        }
    }

    static if (withInterpolation)
    void opBinary(string op : "~", Ts...)(InterpolationHeader, Ts text) {
        pushElementText(text);
    }

    /// Low-level function to write elements into current document context. Raw markup can be used,
    /// i.e. ("<b>Hi</b>")` will include unescaped HTML code.
    ///
    /// If escaping is desired, try [pushElementText].
    ///
    /// Params:
    ///     content = Markup to output.
    void pushElementMarkup(string content) @safe {
        assert(elementOutput !is null,
            "No Elemi context is currently active. Try prepending the document with "
            ~ "`buildDocument() ~`.");
        elementOutput(content);
    }

    /// Low-level function to write escaped text.
    /// Params:
    ///     content = Content to write. Interpolated expression strings (istrings) are supported.
    void pushElementText(string content) {
        while (!content.empty) {
            const nextMarkup = content.indexOfAny(`<>&"'`);

            // No markup remains to be escaped
            if (nextMarkup == -1) {
                pushElementMarkup(content);
                return;
            }

            // Escape the character
            else {
                pushElementMarkup(content[0 .. nextMarkup]);
                pushElementMarkup(content[nextMarkup].escapeHTMLCharacter);
                content = content[nextMarkup + 1 .. $];
            }

        }
    }

    /// ditto
    void pushElementText(Ts...)(Ts content) {

        import std.format.write;

        auto writer = EscapingElementWriter(this);

        foreach (item; content) {
            static if (is(typeof(item) : Element)) {
                pushElementMarkup(item);
            }
            else {
                formattedWrite!"%s"(writer, item);
            }
        }

    }

    /// This output range writes escapes the text it writes.
    private struct EscapingElementWriter {

        DocumentOutput output;

        void put(char content) {
            if (auto escaped = escapeHTMLCharacter(content)) {
                output.pushElementMarkup(escaped);
            }
            else {
                immutable(char)[1] c = content;
                output.pushElementMarkup(c[]);
            }
        }

        void put(string content) {
            output.pushElementText(content);
        }

    }

}

/// Escape an ASCII character using HTML escape codes.
/// Returns:
///     A corresponding HTML escape code, or null if there isn't one.
private string escapeHTMLCharacter(char ch) {
    switch (ch) {
        case '<':  return "&lt;";
        case '>':  return "&gt;";
        case '&':  return "&amp;";
        case '"':  return "&quot;";
        case '\'': return "&#39;";
        default:   return null;
    }
}
