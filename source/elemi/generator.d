/// This module provides syntax for generating HTML and XML documents from inside of D,
/// including control flow.
module elemi.generator;

/// Elements are created using a tilde, followed by curly braces. This syntax is called an
/// **element block**.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.div ~ {
            html.span ~ { };
        };
    };
    assert(output == "<div><span></span></div>");
}

/// Instead of a block, you can follow an element with a string to specify text content.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.p ~ "Hello, World!";
    };
    assert(output == "<p>Hello, World!</p>");
}

/// You can add attributes to an element using the [Tag.attr] method.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.a.attr("href", "https://example.com") ~ "Visit my website!";
    };
    assert(output == `<a href="https://example.com">Visit my website!</a>`);
}

/// Common HTML attributes are available through methods.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.div.id("my-div") ~ { };
        html.div.classes("one", "two", "three") ~ { };
        html.a.href("https://example.com") ~ { };
    };
    assert(output == `<div id="my-div"></div>`
        ~ `<div class="one two three"></div>`
        ~ `<a href="https://example.com"></a>`);
}

/// Generate HTML tags with code.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html.ul ~ {
            foreach (item; ["1", "2", "3"]) {
                html.li ~ item;
            }
        };
    };
    assert(output == `<ul><li>1</li><li>2</li><li>3</li></ul>`);
}

/// Omit the tag name to append text.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ "Hello, ";
        html.strong ~ "World!";
    };
    assert(output == "Hello, <strong>World!</strong>");
}

/// All HTML content is automatically escaped.
@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ "<script>alert('fool!')</script>";
        html.input.attr("value", "\" can't quit me") ~ { };
        html.div.classes("classes are <no exception>") ~ { };
    };

    assert(output == `&lt;script&gt;alert(&#39;fool!&#39;)&lt;/script&gt;`
        ~ `<input value="&quot; can&#39;t quit me"/>`
        ~ `<div class="classes are &lt;no exception&gt;"></div>`);
}

static if (withInterpolation) {
    /// Interpolated expression strings, aka istrings, are supported.
    unittest {
        string output = buildHTML() ~ (html) {
            const user = "<user>";
            html ~ i"Hello $(user)";
            html.div ~ i"Hello $(user)";
            html.div.attr("name", i"$(user)") ~ { };
            html.a.href(i"https://example.com/$(user)") ~ { };
            html.a
                .classes("button", "special")
                .href("https://example.com/") ~ { };
        };
        assert(output == `Hello &lt;user&gt;`
            ~ `<div>Hello &lt;user&gt;</div>`
            ~ `<div name="&lt;user&gt;"></div>`
            ~ `<a href="https://example.com/&lt;user&gt;"></a>`
            ~ `<a class="button special" href="https://example.com/"></a>`);
    }
}

static if (withInterpolation) {

    /// This syntax can be mixed with elements generated by the old syntax.
    @safe unittest {
        string output = buildHTML() ~ (html) {
            html ~ elem!"span"();
            html.div ~ elem!"span"();
            html ~ i"$(elem!"span"())";
        };
        assert(output == `<span></span>`
            ~ `<div><span></span></div>`
            ~ `<span></span>`);
    }

}

/// Elemi works at compile time!
@safe unittest {
    enum output = buildHTML ~ (html) {
        html.div ~ {
            html.p ~ "Hello, World!";
        };
    };
    assert(output == "<div><p>Hello, World!</p></div>");
}

@safe unittest {
    string output = buildHTML() ~ (html) {
        html ~ elem!"p"("Hello, World!");
    };

    assert(output == "<p>Hello, World!</p>");
}

@safe unittest {
    // const(edgecase)
    const element = elem!"p"("Hello, World!");
    string output = buildHTML() ~ (html) {
        html ~ element;
        html ~ i" with $(element)";
    };

    assert(output == "<p>Hello, World!</p> with <p>Hello, World!</p>");
}

import std.meta;
import std.range;
import std.string;
import std.functional;

import elemi.html;
import elemi.element;
import elemi.internal;
import elemi.attribute;

static if (__traits(compiles, { import core.attribute : mustuse; })) {
    import core.attribute : mustuse;
}
else {
    alias mustuse = AliasSeq!();
}

@safe:

/// This special struct writes XML or HTML elements through a predicate function. It accepts an
/// element block `~ { }` as input.
///
/// The predicate can be used with `std.range.input` to write content to an input range.
@mustuse
struct DocumentBuilder {

    void delegate(string fragment) @safe sink;

    void opBinary(string op : "~")(void delegate() @safe build) @safe {
        elementOutput = (string fragment) => unaryFun!fun(fragment);
        scope (exit) elementOutput = null;
        build();
    }

    void opBinary(string op : "~")(void delegate() @system build) @system {
        elementOutput = (string fragment) => unaryFun!fun(fragment);
        scope (exit) elementOutput = null;
        build();
    }

}

/// This special struct writes XML or HTML elements to a string.
///
/// The resulting string is wrapped in an [Element] so it is recognized as a valid element
/// by other parts of the Elemi API.
@mustuse
struct TextDocumentBuilder {

    Element opBinary(string op : "~")(void delegate() @safe build) @safe {
        Appender!string output;
        elementOutput = (string fragment) => output ~= fragment;
        scope (exit) elementOutput = null;
        build();
        return elemTrusted(output[]);
    }

    Element opBinary(string op : "~")(void delegate() @system build) @system {
        Appender!string output;
        elementOutput = (string fragment) => output ~= fragment;
        scope (exit) elementOutput = null;
        build();
        return elemTrusted(output[]);
    }

}

/// Generic XML tag.
@mustuse
struct Tag {

    /// Output target for this tag; HTML code will be written to this destination.
    DocumentOutput output;

    /// Name of this HTML tag.
    string tagName;

    /// If true, this is a "self-closing" tag. No child nodes or text can be added.
    bool isSelfClosing;

    alias output this;

    /// The tag can be marked as self-closing so it does not generate content nor an end tag.
    unittest {
        auto normal = buildHTML() ~ (html) {
            Tag(html, "a") ~ { };
        };
        auto selfClosing = buildHTML() ~ (html) {
            Tag(html, "a").makeSelfClosing() ~ { };
        };

        assert(normal == "<a></a>");
        assert(selfClosing == "<a/>");
    }

    unittest {
        auto normal = buildHTML() ~ (html) {
            Tag(html, "a").attr("k", "k") ~ { };
        };
        auto selfClosing = buildHTML() ~ (html) {
            Tag(html, "a").attr("k", "k").makeSelfClosing() ~ { };
        };

        assert(normal == `<a k="k"></a>`);
        assert(selfClosing == `<a k="k"/>`);
    }

    /// True if an attribute has been added to this tag.
    ///
    /// This changes whether the whole opening tag will be added when content starts (no
    /// attributes), or just the right bracket (with attributes).
    bool withAttributes;

    /// Returns:
    ///     The same tag, but marked using [withAttributes]. This should be used to return from
    ///     attribute-adding methods.
    Tag attributed() const @safe {
        return Tag(output, tagName, isSelfClosing, true);
    }

    /// Returns:
    ///     This tag, but edited to be self-closing.
    Tag makeSelfClosing() const @safe {
        return Tag(output, tagName, true, withAttributes);
    }

    void opBinary(string op : "~")(typeof(null)) @safe {
        begin();
        end();
    }

    void opBinary(string op : "~", T)(T content) @safe {
        begin();
        if (!isSelfClosing) {
            static if (is(T : const Element)) {
                pushElementMarkup(content);
            }
            else {
                pushElementText(content);
            }
            end();
        }
    }

    static if (withInterpolation)
    void opBinary(string op : "~", Ts...)(InterpolationHeader, Ts text) {
        begin();
        if (!isSelfClosing) {
            pushElementText(text);
            end();
        }
    }

    void opBinary(string op : "~")(void delegate() @safe builder) @safe {
        begin();
        if (!isSelfClosing) {
            builder();
            end();
        }
    }

    void opBinary(string op : "~")(void delegate() @system builder) @system {
        begin();
        if (!isSelfClosing) {
            builder();
            end();
        }
    }

    /// Add an attribute to the element.
    /// Params:
    ///     name  = Name of the attribute.
    ///     value = Value for the attribute. Supports istrings.
    /// Returns:
    ///     Tag builder.
    Tag attr(string name, string value) @safe {
        return attr(Attribute(name, value));
    }

    /// ditto
    static if (withInterpolation) {
        Tag attr(Ts...)(string name, InterpolationHeader, Ts value) @safe {
            beginAttributes();
            pushElementMarkup(" ");
            pushElementMarkup(name);
            pushElementMarkup(`="`);
            pushElementText(value);
            pushElementMarkup(`"`);
            return attributed;
        }
    }

    /// Add a prepared set of attributes to the element.
    /// Params:
    ///     attributes = Attributes to add to the element.
    /// Returns:
    ///     Tag builder.
    Tag attr(Attribute[] attributes...) @safe {
        beginAttributes();
        foreach (attribute; attributes) {
            pushElementMarkup(" ");
            pushElementMarkup(attribute.name);
            pushElementMarkup(`="`);
            pushElementText(attribute.value);
            pushElementMarkup(`"`);
        }
        return attributed;
    }

    void begin() @safe {
        if (tagName is null) return;
        if (!withAttributes) {
            pushElementMarkup("<");
            pushElementMarkup(tagName);
        }
        if (isSelfClosing) {
            pushElementMarkup("/>");
        }
        else {
            pushElementMarkup(">");
        }
    }

    void beginAttributes() @safe {
        if (tagName is null) return;
        if (!withAttributes) {
            pushElementMarkup("<");
            pushElementMarkup(tagName);
        }
    }

    void end() @safe {
        if (tagName is null) return;
        if (!isSelfClosing) {
            pushElementMarkup("</");
            pushElementMarkup(tagName);
            pushElementMarkup(">");
        }
    }

}

struct DocumentOutput {

    void delegate(string fragment) @safe elementOutput;

    void opBinary(string op : "~", T : string)(T rhs) @safe {
        static if (is(T : const Element)) {
            pushElementMarkup(rhs);
        }
        else {
            pushElementText(rhs);
        }
    }

    static if (withInterpolation)
    void opBinary(string op : "~", Ts...)(InterpolationHeader, Ts text) {
        pushElementText(text);
    }

    /// Low-level function to write elements into current document context. Raw markup can be used,
    /// i.e. ("<b>Hi</b>")` will include unescaped HTML code.
    ///
    /// If escaping is desired, try [pushElementText].
    ///
    /// Params:
    ///     content = Markup to output.
    void pushElementMarkup(string content) @safe {
        assert(elementOutput !is null,
            "No Elemi context is currently active. Try prepending the document with "
            ~ "`buildDocument() ~`.");
        elementOutput(content);
    }

    /// Low-level function to write escaped text.
    /// Params:
    ///     content = Content to write. Interpolated expression strings (istrings) are supported.
    void pushElementText(string content) {
        while (!content.empty) {
            const nextMarkup = content.indexOfAny(`<>&"'`);

            // No markup remains to be escaped
            if (nextMarkup == -1) {
                pushElementMarkup(content);
                return;
            }

            // Escape the character
            else {
                pushElementMarkup(content[0 .. nextMarkup]);
                pushElementMarkup(content[nextMarkup].escapeXML);
                content = content[nextMarkup + 1 .. $];
            }

        }
    }

    /// ditto
    void pushElementText(Ts...)(Ts content) {

        import std.format.write;

        auto writer = EscapingElementWriter(this);

        foreach (item; content) {
            static if (is(typeof(item) : Element)) {
                pushElementMarkup(item);
            }
            else {
                formattedWrite!"%s"(writer, item);
            }
        }

    }

    /// This output range writes escapes the text it writes.
    private struct EscapingElementWriter {

        DocumentOutput output;

        void put(char content) {
            if (auto escaped = escapeXML(content)) {
                output.pushElementMarkup(escaped);
            }
            else {
                immutable(char)[1] c = content;
                output.pushElementMarkup(c[]);
            }
        }

        void put(string content) {
            output.pushElementText(content);
        }

    }

}

/// Escape an ASCII character using HTML escape codes.
/// Returns:
///     A corresponding HTML escape code, or null if there isn't one.
private string escapeXML(char ch) {
    switch (ch) {
        case '<':  return "&lt;";
        case '>':  return "&gt;";
        case '&':  return "&amp;";
        case '"':  return "&quot;";
        case '\'': return "&#39;";
        default:   return null;
    }
}

/// Generic HTML tag.
struct HTMLTag(string name) {
    enum isVoidTag = name == "area"
        || name == "base"
        || name == "br"
        || name == "col"
        || name == "command"
        || name == "embed"
        || name == "hr"
        || name == "img"
        || name == "input"
        || name == "keygen"
        || name == "link"
        || name == "meta"
        || name == "param"
        || name == "source"
        || name == "track"
        || name == "wbr";

    Tag tag;
    alias tag this;

    this(DocumentOutput output) {
        this.tag = Tag(output, name, isVoidTag);
    }

    this(Tag tag) {
        this.tag = tag;
    }

    HTMLTag attr(Ts...)(Ts args) {
        return HTMLTag(
            tag.attr(args));
    }

    HTMLTag attributed(Ts...)(Ts args) {
        return HTMLTag(
            tag.attributed(args));
    }

    /// Add an `id` attribute to the HTML tag.
    /// Params:
    ///     value = Value to use for the attribute. Supports istrings.
    /// Returns:
    ///     A tag builder.
    HTMLTag id(string value) @safe {
        return attr("id", value);
    }

    static if (withInterpolation) {
        HTMLTag id(Ts...)(InterpolationHeader header, Ts value) @safe {
            return attr("id", header, value);
        }
    }

    /// Add a `class` attribute to a HTML tag.
    /// Params:
    ///     values = Classes to write.
    /// Returns:
    ///     A tag builder.
    HTMLTag classes(string[] values...) @safe {
        beginAttributes();
        pushElementMarkup(` class="`);
        foreach (i, value; values) {
            if (i) pushElementMarkup(" ");
            pushElementText(value);
        }
        pushElementMarkup(`"`);
        return attributed;
    }

    /// Set the "href" attribute for an `<a>` element.
    /// Params:
    ///     value = Value to use for the attribute. Supports istrings.
    /// Returns:
    ///     A tag builder.
    HTMLTag href(string value) @safe {
        return attr("href", value);
    }

    static if (withInterpolation) {
        /// ditto
        HTMLTag href(Ts...)(InterpolationHeader header, Ts value) @safe {
            return attr("href", header, value);
        }
    }

}

/// Write HTML elements to an output range.
/// Params:
///     range = Output range to write the output to. If not given, the builder will return
///         a string.
/// Returns:
///     A struct that accepts an element block `~ (html) { }` and writes the content to the output
///     range.
HTML buildHTML(T)(ref T range)
if (isOutputRange!(T, char))
do {
    return HTML(
        DocumentOutput(fragment => put(range, fragment)));
}

/// Write HTML elements to a string or [Element].
///
/// Returns:
///     A struct that accepts an element block `~ (html) { }` and writes the content to a string.
TextHTML buildHTML() @safe {
    return TextHTML();
}

/// If no arguments are specified, `buildHTML()` will output to a string. Under the hood,
/// it uses an [std.array.Appender].
@safe unittest {
    import std.array;
    string stringOutput = buildHTML() ~ (html) {
        html.p ~ "Hello!";
    };

    Appender!string rangeOutput;
    buildHTML(rangeOutput) ~ (html) {
        html.p ~ "Hello!";
    };
    assert(stringOutput == rangeOutput[]);
}

struct TextHTML {
    import std.array;

    Element opBinary(string op : "~")(void delegate(HTML) @system rhs) const @system {
        Appender!string output;
        rhs(
            HTML(
                DocumentOutput(fragment => output ~= fragment)));
        return elemTrusted(output[]);
    }

    Element opBinary(string op : "~")(void delegate(HTML) @safe rhs) const @safe {
        Appender!string output;
        rhs(
            HTML(
                DocumentOutput(fragment => output ~= fragment)));
        return elemTrusted(output[]);
    }

}

/// A set of HTML tags to build documents with.
struct HTML {

    DocumentOutput documentOutput;

    alias documentOutput this;

    void opBinary(string op : "~", T : string)(T rhs) @safe {
        documentOutput ~ rhs;
    }

    static if (withInterpolation) {
        void opBinary(string op : "~", Ts...)(InterpolationHeader, Ts text) {
            pushElementText(text);
        }
    }

    void opBinary(string op : "~")(void delegate(HTML o) @system rhs) @system {
        rhs(this);
    }

    void opBinary(string op : "~")(void delegate(HTML o) @safe rhs) @safe {
        rhs(this);
    }

    @safe:

    HTMLTag!"a" a() {
        return typeof(return)(this);
    }
    HTMLTag!"abbr" abbr() {
        return typeof(return)(this);
    }
    HTMLTag!"acronym" acronym() {
        return typeof(return)(this);
    }
    HTMLTag!"address" address() {
        return typeof(return)(this);
    }
    HTMLTag!"area" area() {
        return typeof(return)(this);
    }
    HTMLTag!"article" article() {
        return typeof(return)(this);
    }
    HTMLTag!"aside" aside() {
        return typeof(return)(this);
    }
    HTMLTag!"audio" audio() {
        return typeof(return)(this);
    }
    HTMLTag!"b" b() {
        return typeof(return)(this);
    }
    HTMLTag!"base" base() {
        return typeof(return)(this);
    }
    HTMLTag!"bdi" bdi() {
        return typeof(return)(this);
    }
    HTMLTag!"bdo" bdo() {
        return typeof(return)(this);
    }
    HTMLTag!"big" big() {
        return typeof(return)(this);
    }
    HTMLTag!"blockquote" blockquote() {
        return typeof(return)(this);
    }
    HTMLTag!"body" body() {
        return typeof(return)(this);
    }
    HTMLTag!"br" br() {
        return typeof(return)(this);
    }
    HTMLTag!"button" button() {
        return typeof(return)(this);
    }
    HTMLTag!"canvas" canvas() {
        return typeof(return)(this);
    }
    HTMLTag!"caption" caption() {
        return typeof(return)(this);
    }
    HTMLTag!"center" center() {
        return typeof(return)(this);
    }
    HTMLTag!"cite" cite() {
        return typeof(return)(this);
    }
    HTMLTag!"code" code() {
        return typeof(return)(this);
    }
    HTMLTag!"col" col() {
        return typeof(return)(this);
    }
    HTMLTag!"colgroup" colgroup() {
        return typeof(return)(this);
    }
    HTMLTag!"command" command() {
        return typeof(return)(this);
    }
    HTMLTag!"data" data() {
        return typeof(return)(this);
    }
    HTMLTag!"datalist" datalist() {
        return typeof(return)(this);
    }
    HTMLTag!"dd" dd() {
        return typeof(return)(this);
    }
    HTMLTag!"del" del() {
        return typeof(return)(this);
    }
    HTMLTag!"details" details() {
        return typeof(return)(this);
    }
    HTMLTag!"dfn" dfn() {
        return typeof(return)(this);
    }
    HTMLTag!"dialog" dialog() {
        return typeof(return)(this);
    }
    HTMLTag!"dir" dir() {
        return typeof(return)(this);
    }
    HTMLTag!"div" div() {
        return typeof(return)(this);
    }
    HTMLTag!"dl" dl() {
        return typeof(return)(this);
    }
    HTMLTag!"dt" dt() {
        return typeof(return)(this);
    }
    HTMLTag!"em" em() {
        return typeof(return)(this);
    }
    HTMLTag!"embed" embed() {
        return typeof(return)(this);
    }
    HTMLTag!"fencedframe" fencedframe() {
        return typeof(return)(this);
    }
    HTMLTag!"fieldset" fieldset() {
        return typeof(return)(this);
    }
    HTMLTag!"figcaption" figcaption() {
        return typeof(return)(this);
    }
    HTMLTag!"figure" figure() {
        return typeof(return)(this);
    }
    HTMLTag!"font" font() {
        return typeof(return)(this);
    }
    HTMLTag!"footer" footer() {
        return typeof(return)(this);
    }
    HTMLTag!"form" form() {
        return typeof(return)(this);
    }
    HTMLTag!"frame" frame() {
        return typeof(return)(this);
    }
    HTMLTag!"frameset" frameset() {
        return typeof(return)(this);
    }
    HTMLTag!"h1" h1() {
        return typeof(return)(this);
    }
    HTMLTag!"h2" h2() {
        return typeof(return)(this);
    }
    HTMLTag!"h3" h3() {
        return typeof(return)(this);
    }
    HTMLTag!"h4" h4() {
        return typeof(return)(this);
    }
    HTMLTag!"h5" h5() {
        return typeof(return)(this);
    }
    HTMLTag!"h6" h6() {
        return typeof(return)(this);
    }
    HTMLTag!"head" head() {
        return typeof(return)(this);
    }
    HTMLTag!"header" header() {
        return typeof(return)(this);
    }
    HTMLTag!"hgroup" hgroup() {
        return typeof(return)(this);
    }
    HTMLTag!"hr" hr() {
        return typeof(return)(this);
    }
    HTMLTag!"html" html() {
        return typeof(return)(this);
    }
    HTMLTag!"i" i() {
        return typeof(return)(this);
    }
    HTMLTag!"iframe" iframe() {
        return typeof(return)(this);
    }
    HTMLTag!"img" img() {
        return typeof(return)(this);
    }
    HTMLTag!"input" input() {
        return typeof(return)(this);
    }
    HTMLTag!"ins" ins() {
        return typeof(return)(this);
    }
    HTMLTag!"kbd" kbd() {
        return typeof(return)(this);
    }
    HTMLTag!"keygen" keygen() {
        return typeof(return)(this);
    }
    HTMLTag!"label" label() {
        return typeof(return)(this);
    }
    HTMLTag!"legend" legend() {
        return typeof(return)(this);
    }
    HTMLTag!"li" li() {
        return typeof(return)(this);
    }
    HTMLTag!"link" link() {
        return typeof(return)(this);
    }
    HTMLTag!"main" main() {
        return typeof(return)(this);
    }
    HTMLTag!"map" map() {
        return typeof(return)(this);
    }
    HTMLTag!"mark" mark() {
        return typeof(return)(this);
    }
    HTMLTag!"marquee" marquee() {
        return typeof(return)(this);
    }
    HTMLTag!"math" math() {
        return typeof(return)(this);
    }
    HTMLTag!"menu" menu() {
        return typeof(return)(this);
    }
    HTMLTag!"meta" meta() {
        return typeof(return)(this);
    }
    HTMLTag!"meter" meter() {
        return typeof(return)(this);
    }
    HTMLTag!"nav" nav() {
        return typeof(return)(this);
    }
    HTMLTag!"nobr" nobr() {
        return typeof(return)(this);
    }
    HTMLTag!"noembed" noembed() {
        return typeof(return)(this);
    }
    HTMLTag!"noframes" noframes() {
        return typeof(return)(this);
    }
    HTMLTag!"noscript" noscript() {
        return typeof(return)(this);
    }
    HTMLTag!"object" object() {
        return typeof(return)(this);
    }
    HTMLTag!"ol" ol() {
        return typeof(return)(this);
    }
    HTMLTag!"optgroup" optgroup() {
        return typeof(return)(this);
    }
    HTMLTag!"option" option() {
        return typeof(return)(this);
    }
    HTMLTag!"output" output() {
        return typeof(return)(this);
    }
    HTMLTag!"p" p() {
        return typeof(return)(this);
    }
    HTMLTag!"param" param() {
        return typeof(return)(this);
    }
    HTMLTag!"picture" picture() {
        return typeof(return)(this);
    }
    HTMLTag!"plaintext" plaintext() {
        return typeof(return)(this);
    }
    HTMLTag!"pre" pre() {
        return typeof(return)(this);
    }
    HTMLTag!"progress" progress() {
        return typeof(return)(this);
    }
    HTMLTag!"q" q() {
        return typeof(return)(this);
    }
    HTMLTag!"rb" rb() {
        return typeof(return)(this);
    }
    HTMLTag!"rp" rp() {
        return typeof(return)(this);
    }
    HTMLTag!"rt" rt() {
        return typeof(return)(this);
    }
    HTMLTag!"rtc" rtc() {
        return typeof(return)(this);
    }
    HTMLTag!"ruby" ruby() {
        return typeof(return)(this);
    }
    HTMLTag!"s" s() {
        return typeof(return)(this);
    }
    HTMLTag!"samp" samp() {
        return typeof(return)(this);
    }
    HTMLTag!"script" script() {
        return typeof(return)(this);
    }
    HTMLTag!"search" search() {
        return typeof(return)(this);
    }
    HTMLTag!"section" section() {
        return typeof(return)(this);
    }
    HTMLTag!"select" select() {
        return typeof(return)(this);
    }
    HTMLTag!"slot" slot() {
        return typeof(return)(this);
    }
    HTMLTag!"small" small() {
        return typeof(return)(this);
    }
    HTMLTag!"source" source() {
        return typeof(return)(this);
    }
    HTMLTag!"span" span() {
        return typeof(return)(this);
    }
    HTMLTag!"strike" strike() {
        return typeof(return)(this);
    }
    HTMLTag!"strong" strong() {
        return typeof(return)(this);
    }
    HTMLTag!"style" style() {
        return typeof(return)(this);
    }
    HTMLTag!"sub" sub() {
        return typeof(return)(this);
    }
    HTMLTag!"summary" summary() {
        return typeof(return)(this);
    }
    HTMLTag!"sup" sup() {
        return typeof(return)(this);
    }
    HTMLTag!"svg" svg() {
        return typeof(return)(this);
    }
    HTMLTag!"table" table() {
        return typeof(return)(this);
    }
    HTMLTag!"tbody" tbody() {
        return typeof(return)(this);
    }
    HTMLTag!"td" td() {
        return typeof(return)(this);
    }
    HTMLTag!"template" template_() {
        return typeof(return)(this);
    }
    HTMLTag!"textarea" textarea() {
        return typeof(return)(this);
    }
    HTMLTag!"tfoot" tfoot() {
        return typeof(return)(this);
    }
    HTMLTag!"th" th() {
        return typeof(return)(this);
    }
    HTMLTag!"thead" thead() {
        return typeof(return)(this);
    }
    HTMLTag!"time" time() {
        return typeof(return)(this);
    }
    HTMLTag!"title" title() {
        return typeof(return)(this);
    }
    HTMLTag!"tr" tr() {
        return typeof(return)(this);
    }
    HTMLTag!"track" track() {
        return typeof(return)(this);
    }
    HTMLTag!"tt" tt() {
        return typeof(return)(this);
    }
    HTMLTag!"u" u() {
        return typeof(return)(this);
    }
    HTMLTag!"ul" ul() {
        return typeof(return)(this);
    }
    HTMLTag!"var" var() {
        return typeof(return)(this);
    }
    HTMLTag!"video" video() {
        return typeof(return)(this);
    }
    HTMLTag!"wbr" wbr() {
        return typeof(return)(this);
    }
    HTMLTag!"xmp" xmp() {
        return typeof(return)(this);
    }

}
